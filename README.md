这是一个异步的日志程序，并且每天0点会自动写入新的日志文件。

大致实现过程如下：
首先是用到了双缓冲技术，即：开始分配两块内存空间A,B.
另外，开启一个专门的线程T来把日志从内存中写入文件。

思路：
日志先写入A中（内存写，大大节省了时间）返回，
当A中写满或者超时(默认配置的5秒钟)就交换A,B。然后日志写入B中，
而线程T被唤醒，开始把A写入磁盘，由于是单线程操作，不用加锁。


具体情况：

--------------------------------------------------------------
内存BUF： A, B
日志生产者线程：T1, T2...
专门的日志写入磁盘线程：ST

锁：mutex 保证T1, T2写入BUF正确
条件变量：con 用来唤醒ST,同时起到定时作用(pthread_cond_timedwait())
--------------------------------------------------------------

假设目前A被T1,T2操作，而B为ST操作

T1, T2...:
	LOOP:
		LOCK(mutex)
		产生日志；
		if 0点了，需要写入新的日志文件
			设置g_new_fd = 1;//表示需要新的log fd, ST唤醒后会检测到并新建一个文件
			唤醒ST;
			UNLOCK(mutex);
		if A满
			唤醒ST；
			UNLOCK(mutex);
		else 
			日志写入A中；
			UNLOCK(mutex);
			break；//写日志成功,退出循环.
	//注：未成功写日志的需要重新获得锁，来尝试再次写日志


ST:
	LOOP://一直循环
		LOCK(mutex)
		pthread_cond_timedwait()//定时唤醒，
		//ST被唤醒，有一点需要主要，唤醒后，mutex是被ST持有的
		交换A,B；（其实只是交换指向他们的指针而已）
		if g_new_fd == 1 //需要新建一个日志文件
			新建一个new_fd；
			设置g_new_fd = 0;
		UNLOCK(mutex); //及时释放，此时T1,T2线程可以继续写日志了

		把A中的日志全部写入log_fd中;//此时必须是log_fd,而不是new_fd
		if new_fd !=0
			new_fd 赋值给log_fd
			关闭老的log_fd
		







